/*
 * generated by Xtext 2.10.0
 */
package de.jro.tools.jvmmodel

import com.google.inject.Inject
import de.jro.tools.bob.ObjectY
import java.util.List
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.common.types.JvmConstructor
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmField
import org.eclipse.xtext.common.types.JvmFormalParameter
import org.eclipse.xtext.common.types.JvmMember
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import java.util.ArrayList

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class BobyJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * a builder API to programmatically create Jvm elements 
	 * in readable way.
	 */
	@Inject extension JvmTypesBuilder

	@Inject extension IQualifiedNameProvider

	def dispatch void infer(ObjectY bob, IJvmDeclaredTypeAcceptor acceptor, boolean isPrelinkingPhase) {
		acceptor.accept(bob.toClass(bob.fullyQualifiedName)) [
			documentation = bob.documentation
			for (annotation : bob.annotations) {
				annotations += annotation.jvmAnnotationReference
			}
			if (bob.superType != null) {
				superTypes += bob.superType.cloneWithProxies
			}
			// member variables
			members += inferMemberAttr(bob)
			// constructor
			if (bob.immutable) {
				members += inferImmutableConstructor(bob)
			}
			// getter/ setter
			for (property : bob.properties) {
				members += property.toGetter(property.name, property.type)
				if (!bob.immutable) {
					members += property.toSetter(property.name, property.type)
				}
			}
		]
	}

	def EList<JvmMember> inferMemberAttr(ObjectY bob) {
		var EList<JvmMember> attributes = new BasicEList<JvmMember>();
		for (property : bob.properties) {
			var attributeField = property.toField(property.name, property.type)
			for (annotation : property.annotations) {
				attributeField.annotations += annotation.jvmAnnotationReference
			}
			if (bob.immutable) {
				attributeField.final = true
			}
			attributes.add(attributeField)
		}
		return attributes;
	}

	def JvmConstructor inferImmutableConstructor(ObjectY bob) {
		bob.toConstructor [
			val Iterable<JvmField> superTypeFinalFields = superTypeParameters(bob.superType)
			val StringBuilder strBuilder = new StringBuilder;

			if (superTypeFinalFields != null) {
				if (!superTypeFinalFields.empty) {
					strBuilder.append("super(");
				}
				val superParamIterator = superTypeFinalFields.iterator;
				while (superParamIterator.hasNext) {
					val curProp = superParamIterator.next
					parameters += curProp.toParameter(curProp.simpleName, curProp.type)
					strBuilder.append(curProp.simpleName)
					if (superParamIterator.hasNext) {
						strBuilder.append(",")
					}
				}
				if (!superTypeFinalFields.empty) {
					strBuilder.append(");")
					strBuilder.append(System.getProperty("line.separator"))
				}
			}

			val iterator = bob.properties.iterator
			while (iterator.hasNext) {
				val curProp = iterator.next
				parameters += curProp.toParameter(curProp.name, curProp.type)
				strBuilder.append('''this.«curProp.name» = «curProp.name»;''')
				if (iterator.hasNext) {
					strBuilder.append(System.getProperty("line.separator"))
				}
			}
			body = '''«strBuilder.toString»'''
		]
	}

	def List<JvmField> superTypeParameters(JvmTypeReference superType) {
		var List<JvmField> fields = new ArrayList();
		if (superType != null) {
			if (superType.getType() instanceof JvmDeclaredType) {
				var JvmDeclaredType declaredType = superType.getType() as JvmDeclaredType;
				if (declaredType.extendedClass != null) {
					fields.addAll(superTypeParameters(declaredType.extendedClass))
				}
				fields.addAll(declaredType.declaredFields) 
			}
		}
		return fields
	}

}
