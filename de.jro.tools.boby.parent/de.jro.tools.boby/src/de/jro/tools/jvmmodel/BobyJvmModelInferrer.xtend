/*
 * generated by Xtext 2.10.0
 */
package de.jro.tools.jvmmodel

import com.google.inject.Inject
import de.jro.tools.bob.ObjectY
import de.jro.tools.util.SuperTypeAnalyzer
import java.util.List
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.common.types.JvmConstructor
import org.eclipse.xtext.common.types.JvmField
import org.eclipse.xtext.common.types.JvmFormalParameter
import org.eclipse.xtext.common.types.JvmMember
import org.eclipse.xtext.common.types.JvmOperation
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.common.types.util.TypeReferences
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.util.Strings
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class BobyJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * a builder API to programmatically create Jvm elements 
	 * in readable way.
	 */
	@Inject extension JvmTypesBuilder

	@Inject extension IQualifiedNameProvider

	@Inject SuperTypeAnalyzer superTypeAnalyzer
	
	@Inject extension TypeReferences

	def dispatch void infer(ObjectY bob, IJvmDeclaredTypeAcceptor acceptor, boolean isPrelinkingPhase) {
		acceptor.accept(bob.toClass(bob.fullyQualifiedName)) [
			documentation = bob.documentation
			for (annotation : bob.annotations) {
				annotations += annotation.jvmAnnotationReference
			}
			if (bob.superType != null) {
				superTypes += bob.superType.cloneWithProxies
			}
			// member variables
			members += inferMemberAttr(bob)
			// constructor
			if (bob.immutable) {
				members += inferImmutableConstructor(bob)
			}
			// getter/ setter
			for (property : bob.properties) {
				members += property.toGetter(property.name, property.type)
				if (!bob.immutable) {
					members += property.toSetter(property.name, property.type)
				}
			}
			if (!bob.noToString) {
				members += bob.inferToString
			}
		]
	}

	def private EList<JvmMember> inferMemberAttr(ObjectY bob) {
		var EList<JvmMember> attributes = new BasicEList<JvmMember>();
		for (property : bob.properties) {
			var attributeField = property.toField(property.name, property.type)
			for (annotation : property.annotations) {
				attributeField.annotations += annotation.jvmAnnotationReference
			}
			if (bob.immutable) {
				attributeField.final = true
			}
			attributes.add(attributeField)
		}
		return attributes;
	}

	def private JvmConstructor inferImmutableConstructor(ObjectY bob) {
		bob.toConstructor [
			
			val StringBuilder strBuilder = new StringBuilder;
			
			handleSuperType(bob.superType, strBuilder, parameters)

			val iterator = bob.properties.iterator
			while (iterator.hasNext) {
				val curProp = iterator.next
				parameters += curProp.toParameter(curProp.name, curProp.type)
				strBuilder.append('''this.«curProp.name» = «curProp.name»;''')
				if (iterator.hasNext) {
					strBuilder.append(System.getProperty("line.separator"))
				}
			}
			body = '''«strBuilder.toString»'''
		]
	}

	def private handleSuperType(JvmTypeReference superType, StringBuilder strBuilder, EList<JvmFormalParameter> parameters) {
		val Iterable<JvmField> superTypeFinalFields = superTypeAnalyzer.superTypeFinalParametersRecursively(superType)
		if (superTypeFinalFields != null) {
			if (!superTypeFinalFields.empty) {
				strBuilder.append("super(");
			}
			val superParamIterator = superTypeFinalFields.iterator;
			while (superParamIterator.hasNext) {
				val curProp = superParamIterator.next
				parameters += curProp.toParameter(curProp.simpleName, curProp.type)
				strBuilder.append(curProp.simpleName)
				if (superParamIterator.hasNext) {
					strBuilder.append(", ")
				}
			}
			if (!superTypeFinalFields.empty) {
				strBuilder.append(");")
				strBuilder.append(System.getProperty("line.separator"))
			}
		}
	}
	
	def private JvmMember inferToString(ObjectY bob) {
		var JvmTypeReference returnType = typeRef(String);
		
		var JvmOperation operation = bob.toMethod("toString",  returnType) [
			annotations += annotationRef(Override)
			body = '''«bob.createToStringBody»'''
			
		]
		return operation;
	}
	
	def private String createToStringBody(ObjectY bob) {
		var StringBuilder strBuilder = new StringBuilder
		strBuilder.append('''StringBuilder strBuilder = new StringBuilder();
		''')
		strBuilder.append('''strBuilder.append("[");
		''');
		if(bob.superType != null) {
			var List<JvmField> parentParameters = superTypeAnalyzer.superTypeParametersRecursivelyWithPredicate(bob.superType, [!it.isStatic])
			for(field : parentParameters) {
				strBuilder.append(parameterInToString(field.type, field.simpleName))
			}
		}
		for(prop : bob.properties) {
			strBuilder.append(parameterInToString(prop.type, prop.name))
		}
		strBuilder.append('''strBuilder.append("]");
		''');
		strBuilder.append('''return strBuilder.toString();''')
		strBuilder.toString
	}
	
	def private parameterInToString(JvmTypeReference ref, String name) '''
		«IF ref.is(boolean)»
			strBuilder.append(" «name»: " + is«Strings.toFirstUpper(name)»());
		«ELSE»
			strBuilder.append(" «name»: " + get«Strings.toFirstUpper(name)»());
		«ENDIF»
	'''

}
